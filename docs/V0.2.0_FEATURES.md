# Accelerapp v0.2.0 Features Guide

**Last Updated**: 2025-10-14 | **Version**: 1.0.0 (includes v0.2.0 features)

This document provides comprehensive documentation for the features introduced in Accelerapp version 0.2.0, now part of the production 1.0.0 release.

## Table of Contents

1. [Overview](#overview)
2. [Hardware Protocol Support](#hardware-protocol-support)
3. [Code Optimization Agents](#code-optimization-agents)
4. [API and Rate Limiting](#api-and-rate-limiting)
5. [Real-time Collaboration](#real-time-collaboration)
6. [Examples](#examples)

## Overview

Version 0.2.0 introduces major enhancements to Accelerapp's code generation and analysis capabilities:

- **Advanced Hardware Protocols**: I2C, SPI, and CAN bus support with automatic code generation
- **Code Optimization Agents**: AI-powered analysis for performance, memory, quality, and security
- **REST API**: HTTP endpoints for programmatic access to all features
- **Rate Limiting**: Built-in protection against API abuse
- **WebSocket Support**: Real-time agent collaboration and code synchronization

All features maintain backward compatibility with v0.1.0 and integrate seamlessly with existing functionality.

## Hardware Protocol Support

### I2C (Inter-Integrated Circuit)

I2C is a multi-master, multi-slave serial communication protocol commonly used for connecting sensors and peripherals.

#### Configuration

```python
from accelerapp.hardware import I2CConfig, ProtocolGenerator

# Create I2C configuration
config = I2CConfig(
    address=0x76,        # 7-bit device address
    speed=400000,        # 400kHz fast mode
    sda_pin=21,          # SDA data pin (platform-specific)
    scl_pin=22,          # SCL clock pin (platform-specific)
    pullup_enabled=True  # Enable internal pull-ups
)

# Validate configuration
errors = config.validate()
if errors:
    print(f"Configuration errors: {errors}")
```

#### Code Generation

```python
# Generate I2C code for specific platform
arduino_code = ProtocolGenerator.generate_i2c_code(config, "arduino")
esp32_code = ProtocolGenerator.generate_i2c_code(config, "esp32")
stm32_code = ProtocolGenerator.generate_i2c_code(config, "stm32")
```

#### Generated Functions

The generated code includes:
- `setupI2C()` - Initialize I2C hardware
- `i2cWrite(reg, data, len)` - Write data to device register
- `i2cRead(reg, data, len)` - Read data from device register

#### Supported Speeds

- 100 kHz (Standard mode)
- 400 kHz (Fast mode)
- 1 MHz (Fast mode plus)
- 3.4 MHz (High-speed mode)

### SPI (Serial Peripheral Interface)

SPI is a synchronous serial communication protocol used for high-speed data transfer.

#### Configuration

```python
from accelerapp.hardware import SPIConfig, ProtocolGenerator

config = SPIConfig(
    mode=0,           # SPI mode (0-3)
    speed=2000000,    # 2 MHz clock speed
    mosi_pin=23,      # Master Out Slave In
    miso_pin=19,      # Master In Slave Out
    sclk_pin=18,      # Serial Clock
    cs_pin=5,         # Chip Select
    bit_order="MSB"   # MSB or LSB first
)
```

#### SPI Modes

| Mode | Clock Polarity (CPOL) | Clock Phase (CPHA) | Description |
|------|----------------------|-------------------|-------------|
| 0    | 0                    | 0                 | Sample on rising edge |
| 1    | 0                    | 1                 | Sample on falling edge |
| 2    | 1                    | 0                 | Sample on falling edge |
| 3    | 1                    | 1                 | Sample on rising edge |

#### Code Generation

```python
code = ProtocolGenerator.generate_spi_code(config, "arduino")
```

#### Generated Functions

- `setupSPI()` - Initialize SPI hardware
- `spiTransfer(txData, rxData, len)` - Full-duplex transfer
- `spiWrite(data, len)` - Write-only transfer

### CAN (Controller Area Network)

CAN is a robust vehicle bus standard for real-time communication.

#### Configuration

```python
from accelerapp.hardware import CANConfig, ProtocolGenerator

config = CANConfig(
    baudrate=500000,  # 500 kbps
    tx_pin=5,         # Transmit pin
    rx_pin=4,         # Receive pin
    mode="normal"     # normal, loopback, silent, silent-loopback
)
```

#### Standard Baudrates

- 125 kbps
- 250 kbps
- 500 kbps (most common)
- 1 Mbps

#### Code Generation

```python
# CAN is supported on ESP32 and STM32
esp32_code = ProtocolGenerator.generate_can_code(config, "esp32")
stm32_code = ProtocolGenerator.generate_can_code(config, "stm32")
```

#### Generated Functions

- `setupCAN()` - Initialize CAN controller
- `canSend(id, data, len, extended)` - Send CAN message
- `canReceive(message, timeout)` - Receive CAN message

### Device Driver Generation

Accelerapp can automatically generate drivers for common I2C sensors.

#### Supported Sensors

**BME280** - Environmental sensor
```python
driver = DeviceDriverGenerator.generate_sensor_driver("bme280", "i2c", "arduino")
# Provides: readTemperature(), readHumidity(), readPressure()
```

**MPU6050** - Motion sensor
```python
driver = DeviceDriverGenerator.generate_sensor_driver("mpu6050", "i2c", "esp32")
# Provides: readAccel(x, y, z), readGyro(x, y, z)
```

**INA219** - Power monitor
```python
driver = DeviceDriverGenerator.generate_sensor_driver("ina219", "i2c", "stm32")
# Provides: readBusVoltage(), readShuntVoltage(), readCurrent(), readPower()
```

## Code Optimization Agents

### Performance Optimization Agent

Identifies performance bottlenecks and suggests improvements.

```python
from accelerapp.agents import PerformanceOptimizationAgent

agent = PerformanceOptimizationAgent()
result = agent.generate({
    'code': your_code,
    'language': 'cpp'
})

print(f"Issues found: {result['analysis']['issues_found']}")
print(f"Improvement: {result['analysis']['estimated_improvement']}")
```

**Detected Issues:**
- Blocking operations in loops
- Inefficient string concatenation
- High algorithm complexity (nested loops)
- Repeated function calls

**Provides:**
- Issue severity (high, medium, low)
- Optimization suggestions with impact assessment
- Estimated performance improvement percentage

### Memory Optimization Agent

Analyzes memory usage and detects potential leaks.

```python
from accelerapp.agents import MemoryOptimizationAgent

agent = MemoryOptimizationAgent()
result = agent.generate({
    'code': your_code,
    'language': 'cpp',
    'platform': 'arduino'
})

memory_info = result['analysis']['memory_estimate']
print(f"Estimated RAM: {memory_info['estimated_ram_bytes']} bytes")
```

**Detected Issues:**
- Memory leaks (malloc without free, new without delete)
- Large stack allocations
- Inefficient string storage
- Platform-specific issues (Arduino F() macro suggestions)

**Provides:**
- Memory leak detection
- RAM usage estimation
- Platform-specific optimization suggestions

### Code Quality Agent

Enforces coding best practices and calculates quality metrics.

```python
from accelerapp.agents import CodeQualityAgent

agent = CodeQualityAgent()
result = agent.generate({
    'code': your_code,
    'language': 'cpp'
})

analysis = result['analysis']
print(f"Quality Score: {analysis['quality_score']}/100")
print(f"Grade: {analysis['grade']}")
```

**Analyzed Aspects:**
- Function length
- Magic numbers
- Comment density
- Error handling
- Code complexity

**Scoring System:**
- A: 90-100 (Excellent)
- B: 80-89 (Good)
- C: 70-79 (Fair)
- D: 60-69 (Poor)
- F: Below 60 (Needs improvement)

### Security Analysis Agent

Identifies security vulnerabilities and provides remediation advice.

```python
from accelerapp.agents import SecurityAnalysisAgent

agent = SecurityAnalysisAgent()
result = agent.generate({
    'code': your_code,
    'language': 'cpp'
})

analysis = result['analysis']
print(f"Security Score: {analysis['security_score']}/100")
print(f"Risk Level: {analysis['risk_level']}")
```

**Detected Vulnerabilities:**
- Buffer overflow risks (strcpy, gets, strcat)
- SQL injection potential
- Hardcoded credentials
- Integer overflow
- Missing input validation

**Risk Levels:**
- Low: Score 90-100
- Medium: Score 70-89
- High: Score 50-69
- Critical: Score below 50

**CWE References:**
Each vulnerability includes relevant CWE (Common Weakness Enumeration) identifier.

### Refactoring Agent

Identifies code smells and suggests refactoring opportunities.

```python
from accelerapp.agents import RefactoringAgent

agent = RefactoringAgent()
result = agent.generate({
    'code': your_code,
    'language': 'cpp'
})

for smell in result['analysis']['code_smells']:
    print(f"{smell['type']}: {smell['description']}")
```

**Detected Code Smells:**
- Duplicate code blocks
- Long parameter lists (> 4 parameters)
- God objects (too many methods)
- Deeply nested conditionals

**Refactoring Techniques:**
- Extract Method
- Introduce Parameter Object
- Extract Class
- Replace Nested Conditional with Guard Clauses

## API and Rate Limiting

### REST API Endpoints

Start the API server:

```python
from accelerapp.api import CodeGenerationAPI
from accelerapp.core import AccelerappCore

core = AccelerappCore()
api = CodeGenerationAPI(core, host="localhost", port=8080)
api.start()
```

### Available Endpoints

#### Health Check
```
GET /health
```
Returns server status and version.

#### List Agents
```
GET /api/agents
```
Returns available agents and their capabilities.

#### Generate Firmware
```
POST /api/generate/firmware
Authorization: Bearer <api_key>

{
  "platform": "arduino",
  "spec": { ... },
  "use_llm": false
}
```

#### Generate Software SDK
```
POST /api/generate/software
Authorization: Bearer <api_key>

{
  "language": "python",
  "spec": { ... }
}
```

#### Analyze Performance
```
POST /api/analyze/performance
Authorization: Bearer <api_key>

{
  "code": "...",
  "language": "cpp"
}
```

#### Analyze Security
```
POST /api/analyze/security
Authorization: Bearer <api_key>

{
  "code": "...",
  "language": "cpp"
}
```

### Rate Limiting

Protect your API from abuse with built-in rate limiting:

```python
from accelerapp.api import RateLimiter
from accelerapp.api.rate_limiter import RateLimitRule

# Create rate limiter
limiter = RateLimiter()

# Set custom rule for specific client
limiter.set_rule("client_id", RateLimitRule(
    max_requests=100,
    time_window=3600,  # 1 hour
    burst_size=10
))

# Check rate limit
allowed, info = limiter.check_limit("client_id")
if not allowed:
    print(f"Rate limit exceeded. Retry after {info['retry_after']} seconds")
```

**Features:**
- Per-client rate limiting
- Token bucket algorithm
- Configurable time windows
- Burst allowance
- Automatic cleanup of old client data

### API Key Management

Secure your API with key-based authentication:

```python
from accelerapp.api import APIKeyManager

manager = APIKeyManager()

# Generate API key
api_key = manager.generate_key(
    client_id="user123",
    permissions=['read', 'write']
)

# Validate key
valid, client_id = manager.validate_key(api_key)

# Get usage statistics
info = manager.get_key_info(api_key)
print(f"Usage count: {info['usage_count']}")

# Revoke key
manager.revoke_key(api_key)
```

**Features:**
- Secure key generation using Python's secrets module
- Permission-based access control
- Usage tracking and statistics
- Key revocation
- Automatic key prefix for identification

## Real-time Collaboration

### WebSocket Server

Enable real-time agent collaboration:

```python
from accelerapp.communication import WebSocketCollaborationServer
import asyncio

async def start_server():
    server = WebSocketCollaborationServer(host="localhost", port=8765)
    await server.start()
    
    # Server now running at ws://localhost:8765

asyncio.run(start_server())
```

### Event Types

- `AGENT_CONNECTED` - New agent connected
- `AGENT_DISCONNECTED` - Agent disconnected
- `CODE_CHANGED` - Code was modified
- `AGENT_STATUS` - Agent status update
- `TASK_STARTED` - Task began
- `TASK_COMPLETED` - Task finished
- `MESSAGE` - Generic message
- `SYNC_REQUEST` - Request current state
- `SYNC_RESPONSE` - State sync response

### WebSocket Client

Connect to collaboration server:

```python
from accelerapp.communication.websocket_server import WebSocketClient
import asyncio

async def connect():
    client = WebSocketClient(
        server_url="ws://localhost:8765",
        agent_id="my_agent",
        role="developer"
    )
    
    await client.connect()
    
    # Send code update
    await client.send_code_update("main.cpp", "// Updated code")
    
    # Request sync
    await client.request_sync()

asyncio.run(connect())
```

**Note:** WebSocket support requires the `websockets` package:
```bash
pip install websockets
```

## Examples

### Complete Workflow Example

```python
from accelerapp.hardware import I2CConfig, ProtocolGenerator, DeviceDriverGenerator
from accelerapp.agents import (
    PerformanceOptimizationAgent,
    MemoryOptimizationAgent,
    SecurityAnalysisAgent
)

# 1. Generate I2C protocol code
i2c_config = I2CConfig(address=0x76, speed=400000)
protocol_code = ProtocolGenerator.generate_i2c_code(i2c_config, "esp32")

# 2. Generate sensor driver
sensor_driver = DeviceDriverGenerator.generate_sensor_driver(
    "bme280", "i2c", "esp32"
)

# 3. Combine code
complete_code = protocol_code + "\n\n" + sensor_driver

# 4. Analyze performance
perf_agent = PerformanceOptimizationAgent()
perf_result = perf_agent.generate({'code': complete_code, 'language': 'cpp'})
print(f"Performance score: {perf_result['analysis']['estimated_improvement']}")

# 5. Check for memory issues
mem_agent = MemoryOptimizationAgent()
mem_result = mem_agent.generate({
    'code': complete_code,
    'language': 'cpp',
    'platform': 'esp32'
})
print(f"Memory issues: {mem_result['analysis']['issues_found']}")

# 6. Security audit
sec_agent = SecurityAnalysisAgent()
sec_result = sec_agent.generate({'code': complete_code, 'language': 'cpp'})
print(f"Security score: {sec_result['analysis']['security_score']}/100")
```

### API Integration Example

```python
import requests

# Base URL
API_URL = "http://localhost:8080"
API_KEY = "acc_your_api_key_here"

headers = {
    "Authorization": f"Bearer {API_KEY}",
    "Content-Type": "application/json"
}

# Generate firmware
response = requests.post(
    f"{API_URL}/api/generate/firmware",
    headers=headers,
    json={
        "platform": "esp32",
        "spec": {
            "device_name": "Temperature Monitor",
            "peripherals": ["i2c", "wifi"]
        }
    }
)

firmware = response.json()
print(firmware['code'])

# Analyze security
response = requests.post(
    f"{API_URL}/api/analyze/security",
    headers=headers,
    json={
        "code": firmware['code'],
        "language": "cpp"
    }
)

security_report = response.json()
print(f"Security score: {security_report['analysis']['security_score']}")
```

## Best Practices

### Hardware Protocols

1. **Always validate configurations** before generating code
2. **Use appropriate speeds** for your devices and wiring
3. **Consider pull-up resistors** for I2C (external or internal)
4. **Check pin availability** on your target platform
5. **Test generated code** with actual hardware

### Optimization Agents

1. **Run multiple agents** for comprehensive analysis
2. **Prioritize critical issues** (security, memory leaks)
3. **Review suggestions** before applying changes
4. **Test after optimization** to ensure correctness
5. **Iterate** - run agents after each major change

### API Usage

1. **Implement rate limiting** to prevent abuse
2. **Use API keys** for authentication
3. **Monitor usage statistics** for capacity planning
4. **Handle rate limit errors** gracefully with retries
5. **Keep API keys secure** - never commit to version control

### WebSocket Collaboration

1. **Use unique agent IDs** for proper tracking
2. **Handle disconnections** gracefully
3. **Implement reconnection logic** for reliability
4. **Validate messages** before processing
5. **Monitor connection health** with ping/pong

## Migration from v0.1.0

Version 0.2.0 is fully backward compatible with v0.1.0. No changes are required to existing code.

To use new features:

```python
# Add new imports
from accelerapp.hardware import I2CConfig, ProtocolGenerator
from accelerapp.agents import PerformanceOptimizationAgent
from accelerapp.api import RateLimiter, APIKeyManager

# Your existing v0.1.0 code continues to work
from accelerapp import AccelerappCore
core = AccelerappCore()
# ... existing code ...
```

## Troubleshooting

### WebSocket Connection Issues

If WebSocket features are unavailable:
```bash
pip install websockets
```

### API Server Not Starting

Check if HTTP server modules are available (they should be in standard library):
```python
from http.server import HTTPServer  # Should work without install
```

### Rate Limit Errors

If you're getting rate limited:
1. Check current usage: `limiter.get_client_info(client_id)`
2. Wait for window reset: `info['reset_time']`
3. Or reset manually: `limiter.reset_client(client_id)`

### Memory Issues with Agents

If agents consume too much memory:
- Process code in smaller chunks
- Use streaming for large codebases
- Cleanup limiter periodically: `limiter.cleanup_old_clients()`

## Support and Resources

- **Documentation**: `/docs` directory
- **Examples**: `/examples` directory
- **Tests**: `/tests` directory for usage examples
- **Issues**: GitHub issue tracker
- **Changelog**: `CHANGELOG.md` for all changes

## License

Accelerapp v0.2.0 is released under the MIT License. See LICENSE file for details.
