"""
Meshtastic platform support for code generation.
Provides platform-specific code generation for Meshtastic devices.
"""

from typing import Dict, Any, List
from pathlib import Path
from .base import BasePlatform


class MeshtasticESP32Platform(BasePlatform):
    """
    Meshtastic platform for ESP32-based devices.
    Supports SX1276 and SX1262 LoRa radios.
    """
    
    def __init__(self):
        """Initialize Meshtastic ESP32 platform."""
        super().__init__()
        self.name = "meshtastic-esp32"
        self.architecture = "xtensa"
        self.compiler = "xtensa-esp32-elf-gcc"
    
    def validate_config(self, config: Dict[str, Any]) -> List[str]:
        """
        Validate Meshtastic ESP32 configuration.
        
        Args:
            config: Configuration to validate
            
        Returns:
            List of validation errors
        """
        errors = []
        
        if "radio_config" in config:
            radio_config = config["radio_config"]
            
            # Validate frequency
            frequency = radio_config.get("frequency", 915.0)
            if frequency not in [433.0, 868.0, 915.0]:
                errors.append(f"Invalid frequency: {frequency}. Must be 433, 868, or 915 MHz")
            
            # Validate spreading factor
            sf = radio_config.get("spreading_factor", 7)
            if not 6 <= sf <= 12:
                errors.append(f"Invalid spreading factor: {sf}. Must be 6-12")
            
            # Validate power
            power = radio_config.get("power", 20)
            if not 0 <= power <= 20:
                errors.append(f"Invalid power: {power}. Must be 0-20 dBm")
        
        return errors
    
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform information."""
        return {
            "name": self.name,
            "architecture": self.architecture,
            "family": "Meshtastic",
            "base_platform": "ESP32",
            "supported_radios": ["SX1276", "SX1262", "SX1268"],
            "frequencies": ["433MHz", "868MHz", "915MHz"],
            "max_power": 20,  # dBm
            "capabilities": [
                "LoRa mesh networking",
                "WiFi connectivity",
                "Bluetooth LE",
                "GPS support",
                "Battery monitoring",
                "Environment sensors",
            ],
        }
    
    def generate_code(self, spec: Dict[str, Any], output_dir: Path) -> Dict[str, Any]:
        """
        Generate Meshtastic code for ESP32.
        
        Args:
            spec: Hardware specification
            output_dir: Output directory
            
        Returns:
            Generation result
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        
        device_name = spec.get("device_name", "MeshtasticNode")
        features = spec.get("features", [])
        radio_config = spec.get("radio_config", {})
        
        # Generate main source file
        main_code = self._generate_main(device_name, features, radio_config)
        main_file = output_dir / "main.cpp"
        main_file.write_text(main_code)
        
        # Generate configuration header
        config_code = self._generate_config(device_name, features, radio_config)
        config_file = output_dir / "config.h"
        config_file.write_text(config_code)
        
        # Generate platformio.ini
        platformio_code = self._generate_platformio_config(device_name)
        platformio_file = output_dir / "platformio.ini"
        platformio_file.write_text(platformio_code)
        
        return {
            "status": "success",
            "platform": self.name,
            "files_generated": [str(main_file), str(config_file), str(platformio_file)],
            "output_dir": str(output_dir),
        }
    
    def _generate_main(
        self,
        device_name: str,
        features: List[str],
        radio_config: Dict[str, Any]
    ) -> str:
        """Generate main source file."""
        
        includes = ["<Arduino.h>", "<RadioLib.h>", '"config.h"']
        
        if "wifi" in features:
            includes.append("<WiFi.h>")
        if "bluetooth" in features:
            includes.append("<BluetoothSerial.h>")
        if "gps" in features:
            includes.append("<TinyGPS++.h>")
        
        return f'''// Meshtastic Node - {device_name}
// Platform: ESP32
// Generated by: Accelerapp Platform

{chr(10).join(f"#include {inc}" for inc in includes)}

// LoRa radio instance
SX1276 radio = new Module(LORA_CS, LORA_DIO0, LORA_RST, LORA_DIO1);

// Global state
struct NodeState {{
    uint32_t nodeId;
    uint8_t hopCount;
    int16_t lastRSSI;
    float lastSNR;
    uint32_t messagesSent;
    uint32_t messagesReceived;
}} nodeState;

void setup() {{
    Serial.begin(115200);
    delay(1000);
    Serial.println("=================================");
    Serial.println("Meshtastic Node: {device_name}");
    Serial.println("=================================");
    
    // Initialize node state
    nodeState.nodeId = NODE_ID;
    nodeState.hopCount = 0;
    nodeState.lastRSSI = 0;
    nodeState.lastSNR = 0;
    nodeState.messagesSent = 0;
    nodeState.messagesReceived = 0;
    
    // Initialize LoRa radio
    Serial.print("Initializing LoRa radio... ");
    int state = radio.begin();
    if (state == RADIOLIB_ERR_NONE) {{
        Serial.println("success!");
    }} else {{
        Serial.print("failed, code ");
        Serial.println(state);
        while (true);
    }}
    
    // Configure radio parameters
    radio.setFrequency(LORA_FREQUENCY);
    radio.setBandwidth(LORA_BANDWIDTH);
    radio.setSpreadingFactor(LORA_SPREADING_FACTOR);
    radio.setCodingRate(LORA_CODING_RATE);
    radio.setSyncWord(LORA_SYNC_WORD);
    radio.setOutputPower(LORA_POWER);
    
    Serial.println("Radio configured:");
    Serial.print("  Frequency: "); Serial.print(LORA_FREQUENCY); Serial.println(" MHz");
    Serial.print("  Bandwidth: "); Serial.print(LORA_BANDWIDTH); Serial.println(" kHz");
    Serial.print("  Spreading Factor: "); Serial.println(LORA_SPREADING_FACTOR);
    Serial.print("  Power: "); Serial.print(LORA_POWER); Serial.println(" dBm");
    
    {"initializeWiFi();" if "wifi" in features else ""}
    {"initializeBluetooth();" if "bluetooth" in features else ""}
    {"initializeGPS();" if "gps" in features else ""}
    
    Serial.println("Node ready!");
    Serial.println();
}}

void loop() {{
    // Check for incoming messages
    String message;
    int state = radio.receive(message);
    
    if (state == RADIOLIB_ERR_NONE) {{
        // Message received successfully
        nodeState.messagesReceived++;
        nodeState.lastRSSI = radio.getRSSI();
        nodeState.lastSNR = radio.getSNR();
        
        Serial.print("Received [");
        Serial.print(nodeState.messagesReceived);
        Serial.print("] RSSI: ");
        Serial.print(nodeState.lastRSSI);
        Serial.print(" dBm, SNR: ");
        Serial.print(nodeState.lastSNR);
        Serial.print(" dB, Data: ");
        Serial.println(message);
        
        handleMeshMessage(message);
    }} else if (state != RADIOLIB_ERR_RX_TIMEOUT) {{
        // Other error occurred
        Serial.print("Receive failed, code ");
        Serial.println(state);
    }}
    
    // Periodic beacon transmission
    static unsigned long lastBeacon = 0;
    if (millis() - lastBeacon > BEACON_INTERVAL_MS) {{
        sendBeacon();
        lastBeacon = millis();
    }}
    
    delay(10);
}}

void handleMeshMessage(String message) {{
    // Parse and process mesh message
    // This is a simplified implementation
    
    // Check message type (beacon, data, ack, etc.)
    if (message.startsWith("BEACON:")) {{
        // Process beacon message
        Serial.println("Received beacon from neighbor");
    }} else if (message.startsWith("DATA:")) {{
        // Process data message
        Serial.println("Received data message");
    }}
}}

void sendBeacon() {{
    String beacon = "BEACON:" + String(NODE_ID, HEX);
    
    int state = radio.transmit(beacon);
    if (state == RADIOLIB_ERR_NONE) {{
        nodeState.messagesSent++;
        Serial.print("Beacon sent [");
        Serial.print(nodeState.messagesSent);
        Serial.println("]");
    }} else {{
        Serial.print("Beacon failed, code ");
        Serial.println(state);
    }}
}}

void sendMeshMessage(String message, uint32_t destination) {{
    String packet = "DATA:" + String(NODE_ID, HEX) + ">" + String(destination, HEX) + ":" + message;
    
    int state = radio.transmit(packet);
    if (state == RADIOLIB_ERR_NONE) {{
        nodeState.messagesSent++;
        Serial.println("Message sent successfully");
    }} else {{
        Serial.print("Send failed, code ");
        Serial.println(state);
    }}
}}

{"void initializeWiFi() { Serial.println(\"WiFi initialized\"); }" if "wifi" in features else ""}
{"void initializeBluetooth() { Serial.println(\"Bluetooth initialized\"); }" if "bluetooth" in features else ""}
{"void initializeGPS() { Serial.println(\"GPS initialized\"); }" if "gps" in features else ""}
'''
    
    def _generate_config(
        self,
        device_name: str,
        features: List[str],
        radio_config: Dict[str, Any]
    ) -> str:
        """Generate configuration header."""
        
        frequency = radio_config.get("frequency", 915.0)
        bandwidth = radio_config.get("bandwidth", 125.0)
        spreading_factor = radio_config.get("spreading_factor", 7)
        
        return f'''// Meshtastic Configuration
// Device: {device_name}

#ifndef CONFIG_H
#define CONFIG_H

// Device Configuration
#define DEVICE_NAME "{device_name}"
#define NODE_ID 0x{hash(device_name) & 0xFFFFFFFF:08X}

// LoRa Radio Configuration
#define LORA_FREQUENCY {frequency}      // MHz
#define LORA_BANDWIDTH {bandwidth}      // kHz
#define LORA_SPREADING_FACTOR {spreading_factor}
#define LORA_CODING_RATE 5
#define LORA_SYNC_WORD 0x12
#define LORA_POWER {radio_config.get("power", 20)}               // dBm

// ESP32 Pin Configuration (TTGO T-Beam compatible)
#define LORA_CS 18
#define LORA_DIO0 26
#define LORA_RST 23
#define LORA_DIO1 33

// Mesh Configuration
#define MAX_HOPS {radio_config.get("max_hops", 3)}
#define MESH_TIMEOUT_MS {radio_config.get("timeout_ms", 30000)}
#define BEACON_INTERVAL_MS {radio_config.get("beacon_interval_ms", 60000)}

// Feature Configuration
{"#define FEATURE_WIFI" if "wifi" in features else "// WiFi disabled"}
{"#define FEATURE_BLUETOOTH" if "bluetooth" in features else "// Bluetooth disabled"}
{"#define FEATURE_GPS" if "gps" in features else "// GPS disabled"}
{"#define FEATURE_DISPLAY" if "display" in features else "// Display disabled"}
{"#define FEATURE_ENVIRONMENT" if "environment" in features else "// Environment sensors disabled"}

#endif // CONFIG_H
'''
    
    def _generate_platformio_config(self, device_name: str) -> str:
        """Generate PlatformIO configuration."""
        
        return f'''; PlatformIO Project Configuration
; Meshtastic Node: {device_name}

[env:esp32]
platform = espressif32
board = ttgo-t-beam
framework = arduino

; Build flags
build_flags = 
    -DDEVICE_NAME="{device_name}"
    -DCORE_DEBUG_LEVEL=3

; Library dependencies
lib_deps = 
    jgromes/RadioLib@^6.0.0
    mikalhart/TinyGPSPlus@^1.0.3

; Upload settings
upload_speed = 921600
monitor_speed = 115200

; Serial monitor
monitor_filters = 
    default
    time
'''


class MeshtasticNRF52Platform(BasePlatform):
    """
    Meshtastic platform for nRF52-based devices.
    Supports SX1262 LoRa radio.
    """
    
    def __init__(self):
        """Initialize Meshtastic nRF52 platform."""
        super().__init__()
        self.name = "meshtastic-nrf52"
        self.architecture = "arm-cortex-m4"
        self.compiler = "arm-none-eabi-gcc"
    
    def validate_config(self, config: Dict[str, Any]) -> List[str]:
        """
        Validate Meshtastic nRF52 configuration.
        
        Args:
            config: Configuration to validate
            
        Returns:
            List of validation errors
        """
        errors = []
        
        if "radio_config" in config:
            radio_config = config["radio_config"]
            
            # Validate frequency (nRF52 typically 868/915)
            frequency = radio_config.get("frequency", 915.0)
            if frequency not in [868.0, 915.0]:
                errors.append(f"Invalid frequency: {frequency}. Must be 868 or 915 MHz for nRF52")
            
            # Validate power (max 22 dBm for nRF52)
            power = radio_config.get("power", 20)
            if not 0 <= power <= 22:
                errors.append(f"Invalid power: {power}. Must be 0-22 dBm for nRF52")
        
        return errors
    
    def get_platform_info(self) -> Dict[str, Any]:
        """Get platform information."""
        return {
            "name": self.name,
            "architecture": self.architecture,
            "family": "Meshtastic",
            "base_platform": "nRF52",
            "supported_radios": ["SX1262"],
            "frequencies": ["868MHz", "915MHz"],
            "max_power": 22,  # dBm
            "capabilities": [
                "LoRa mesh networking",
                "Bluetooth LE",
                "Low power operation",
                "GPS support",
                "Battery monitoring",
            ],
        }
    
    def generate_code(self, spec: Dict[str, Any], output_dir: Path) -> Dict[str, Any]:
        """
        Generate Meshtastic code for nRF52.
        
        Args:
            spec: Hardware specification
            output_dir: Output directory
            
        Returns:
            Generation result
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        
        device_name = spec.get("device_name", "MeshtasticNode")
        
        # Generate basic nRF52 structure
        main_file = output_dir / "main.cpp"
        main_file.write_text(f'''// Meshtastic Node - {device_name}
// Platform: nRF52
// Generated by: Accelerapp Platform

#include <Arduino.h>
#include <RadioLib.h>

// SX1262 radio for nRF52
SX1262 radio = new Module(8, 3, 2, 4);

void setup() {{
    Serial.begin(115200);
    Serial.println("{device_name} (nRF52) starting...");
    
    // Initialize radio
    int state = radio.begin();
    if (state == RADIOLIB_ERR_NONE) {{
        Serial.println("LoRa initialized");
    }}
}}

void loop() {{
    // Nordic-specific mesh operations
    delay(100);
}}
''')
        
        return {
            "status": "success",
            "platform": self.name,
            "files_generated": [str(main_file)],
            "output_dir": str(output_dir),
        }
