"""
Agentic code generator for CYD projects.

Provides AI-powered code generation capabilities for CYD applications.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum


class CodeStyle(Enum):
    """Code generation styles."""
    MINIMAL = "minimal"
    DOCUMENTED = "documented"
    PRODUCTION = "production"
    EDUCATIONAL = "educational"


@dataclass
class GenerationRequest:
    """Code generation request."""
    project_name: str
    description: str
    requirements: List[str]
    style: CodeStyle = CodeStyle.DOCUMENTED
    platform: str = "arduino"
    optimization_level: int = 1  # 0-3


@dataclass
class GeneratedCode:
    """Generated code result."""
    main_code: str
    header_files: Dict[str, str]
    config_files: Dict[str, str]
    documentation: str
    dependencies: List[str]


class CYDCodeGenerator:
    """
    AI-powered code generator for CYD projects.
    
    Provides capabilities for:
    - Automatic project structure generation
    - Context-aware code completion
    - Best practice enforcement
    - Multi-platform code generation
    - Optimization suggestions
    """

    def __init__(self):
        """Initialize code generator."""
        self._templates_cache: Dict[str, str] = {}

    def generate_project(self, request: GenerationRequest) -> GeneratedCode:
        """
        Generate complete CYD project code.
        
        Args:
            request: Code generation request
            
        Returns:
            Generated code package
        """
        main_code = self._generate_main_code(request)
        headers = self._generate_headers(request)
        configs = self._generate_configs(request)
        docs = self._generate_documentation(request)
        deps = self._identify_dependencies(request)
        
        return GeneratedCode(
            main_code=main_code,
            header_files=headers,
            config_files=configs,
            documentation=docs,
            dependencies=deps,
        )

    def _generate_main_code(self, request: GenerationRequest) -> str:
        """Generate main application code."""
        if request.platform == "arduino":
            return self._generate_arduino_main(request)
        elif request.platform == "esp-idf":
            return self._generate_esp_idf_main(request)
        elif request.platform == "micropython":
            return self._generate_micropython_main(request)
        else:
            return ""

    def _generate_arduino_main(self, request: GenerationRequest) -> str:
        """Generate Arduino main code."""
        has_display = any(r in ["display", "screen", "tft"] for r in request.requirements)
        has_touch = any(r in ["touch", "touchscreen"] for r in request.requirements)
        has_wifi = any(r in ["wifi", "network", "internet"] for r in request.requirements)
        
        includes = ["#include <Arduino.h>"]
        if has_display:
            includes.append("#include <Adafruit_ILI9341.h>")
            includes.append("#include <SPI.h>")
        if has_touch:
            includes.append("#include <XPT2046_Touchscreen.h>")
        if has_wifi:
            includes.append("#include <WiFi.h>")
        
        code = f"""/*
 * {request.project_name}
 * {request.description}
 * 
 * Generated by Accelerapp CYD Code Generator
 * Platform: Arduino
 */

{chr(10).join(includes)}

// Pin definitions
#define TFT_DC 2
#define TFT_CS 15
#define TFT_BL 21
#define TOUCH_CS 33
#define TOUCH_IRQ 36

"""
        
        if has_display:
            code += "Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC);\n"
        if has_touch:
            code += "XPT2046_Touchscreen touch(TOUCH_CS, TOUCH_IRQ);\n"
        
        code += """
void setup() {
    Serial.begin(115200);
    Serial.println("Starting %s...");
    
""" % request.project_name
        
        if has_display:
            code += """    // Initialize display
    pinMode(TFT_BL, OUTPUT);
    digitalWrite(TFT_BL, HIGH);
    tft.begin();
    tft.setRotation(1);
    tft.fillScreen(ILI9341_BLACK);
    tft.setTextColor(ILI9341_WHITE);
    tft.setTextSize(2);
    tft.setCursor(10, 100);
    tft.println("Ready!");
    
"""
        
        if has_touch:
            code += """    // Initialize touch
    touch.begin();
    touch.setRotation(1);
    
"""
        
        if has_wifi:
            code += """    // Initialize WiFi
    WiFi.mode(WIFI_STA);
    // WiFi.begin("SSID", "PASSWORD");
    
"""
        
        code += """    Serial.println("Setup complete!");
}

void loop() {
    // Main application loop
    
"""
        
        if has_touch:
            code += """    // Check for touch input
    if (touch.touched()) {
        TS_Point p = touch.getPoint();
        int x = map(p.x, 200, 3800, 0, 320);
        int y = map(p.y, 200, 3800, 0, 240);
        // Handle touch at (x, y)
    }
    
"""
        
        code += """    delay(10);
}
"""
        
        return code.strip()

    def _generate_esp_idf_main(self, request: GenerationRequest) -> str:
        """Generate ESP-IDF main code."""
        return f"""/*
 * {request.project_name}
 * {request.description}
 * 
 * Generated by Accelerapp CYD Code Generator
 * Platform: ESP-IDF
 */

#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "nvs_flash.h"

void app_main(void) {{
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {{
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }}
    ESP_ERROR_CHECK(ret);
    
    printf("Starting {request.project_name}...\\n");
    
    // Main application logic
    while (1) {{
        vTaskDelay(pdMS_TO_TICKS(1000));
    }}
}}
"""

    def _generate_micropython_main(self, request: GenerationRequest) -> str:
        """Generate MicroPython main code."""
        has_display = any(r in ["display", "screen", "tft"] for r in request.requirements)
        has_touch = any(r in ["touch", "touchscreen"] for r in request.requirements)
        
        code = f"""# {request.project_name}
# {request.description}
# 
# Generated by Accelerapp CYD Code Generator
# Platform: MicroPython

from machine import Pin, SPI
import time

"""
        
        if has_display:
            code += """import ili9341

# Display setup
display = ili9341.Display(
    SPI(2, baudrate=40000000),
    dc=Pin(2),
    cs=Pin(15),
    rotation=1
)

backlight = Pin(21, Pin.OUT)
backlight.value(1)

"""
        
        if has_touch:
            code += """import xpt2046

# Touch setup
touch = xpt2046.Touch(
    SPI(2, baudrate=2000000),
    cs=Pin(33),
    int_pin=Pin(36)
)

"""
        
        code += """def main():
    print("Starting %s...")
    
    while True:
""" % request.project_name
        
        if has_touch:
            code += """        if touch.touched():
            x, y = touch.get_touch()
            print(f"Touch at ({x}, {y})")
        
"""
        
        code += """        time.sleep(0.01)

if __name__ == "__main__":
    main()
"""
        
        return code.strip()

    def _generate_headers(self, request: GenerationRequest) -> Dict[str, str]:
        """Generate header files."""
        return {}

    def _generate_configs(self, request: GenerationRequest) -> Dict[str, str]:
        """Generate configuration files."""
        configs = {}
        
        if request.platform == "arduino":
            configs["platformio.ini"] = self._generate_platformio_config(request)
        
        return configs

    def _generate_platformio_config(self, request: GenerationRequest) -> str:
        """Generate PlatformIO configuration."""
        config = f"""[env:esp32]
platform = espressif32
board = esp32dev
framework = arduino

monitor_speed = 115200

lib_deps = 
    adafruit/Adafruit ILI9341
    adafruit/Adafruit GFX Library
    paulstoffregen/XPT2046_Touchscreen
"""
        
        if any(r in ["wifi", "network"] for r in request.requirements):
            config += "    # WiFi libraries included in framework\n"
        
        return config.strip()

    def _generate_documentation(self, request: GenerationRequest) -> str:
        """Generate project documentation."""
        return f"""# {request.project_name}

{request.description}

## Hardware Requirements

- ESP32-2432S028 (CYD) board
- USB cable for programming

## Software Requirements

- {request.platform.upper()} development environment
- Required libraries (see dependencies)

## Setup Instructions

1. Install required dependencies
2. Connect CYD board via USB
3. Build and upload the firmware
4. Open serial monitor to view output

## Features

{chr(10).join(f"- {req}" for req in request.requirements)}

## Usage

[Add usage instructions here]

## Generated by

Accelerapp CYD Code Generator
Style: {request.style.value}
Platform: {request.platform}
"""

    def _identify_dependencies(self, request: GenerationRequest) -> List[str]:
        """Identify required dependencies."""
        deps = []
        
        if any(r in ["display", "screen", "tft"] for r in request.requirements):
            deps.extend(["Adafruit_ILI9341", "Adafruit_GFX"])
        
        if any(r in ["touch", "touchscreen"] for r in request.requirements):
            deps.append("XPT2046_Touchscreen")
        
        if any(r in ["json", "data"] for r in request.requirements):
            deps.append("ArduinoJson")
        
        if any(r in ["wifi", "network", "http"] for r in request.requirements):
            deps.append("WiFi")
        
        return deps

    def optimize_code(self, code: str, level: int = 1) -> str:
        """
        Optimize generated code.
        
        Args:
            code: Source code to optimize
            level: Optimization level (0-3)
            
        Returns:
            Optimized code
        """
        # Simple optimization: remove excessive blank lines
        lines = code.split("\n")
        optimized = []
        prev_blank = False
        
        for line in lines:
            is_blank = line.strip() == ""
            if is_blank and prev_blank:
                continue
            optimized.append(line)
            prev_blank = is_blank
        
        return "\n".join(optimized)

    def suggest_improvements(self, code: str) -> List[str]:
        """
        Suggest code improvements.
        
        Args:
            code: Source code to analyze
            
        Returns:
            List of improvement suggestions
        """
        suggestions = []
        
        if "delay(" in code and "1000)" in code:
            suggestions.append("Consider using non-blocking delays for better responsiveness")
        
        if "Serial.print" not in code:
            suggestions.append("Add serial debug output for easier troubleshooting")
        
        if "while(1)" in code or "while (1)" in code:
            suggestions.append("Consider adding a watchdog timer for reliability")
        
        return suggestions
