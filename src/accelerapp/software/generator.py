"""
Software generator for host-side drivers and APIs.
"""

from typing import Dict, Any
from pathlib import Path


class SoftwareGenerator:
    """
    Generates host-side software for interacting with hardware.
    Supports Python, C++, and JavaScript SDKs.
    """

    def __init__(self, hardware_spec: Dict[str, Any]):
        """
        Initialize software generator.

        Args:
            hardware_spec: Hardware specification dictionary
        """
        self.hardware_spec = hardware_spec
        self.language = hardware_spec.get("software_language", "python")

    def generate(self, output_dir: Path) -> Dict[str, Any]:
        """
        Generate software based on hardware specification.

        Args:
            output_dir: Directory to write generated software

        Returns:
            Dictionary with generation results
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        if self.language == "python":
            return self._generate_python_sdk(output_dir)
        elif self.language == "cpp":
            return self._generate_cpp_sdk(output_dir)
        elif self.language == "javascript":
            return self._generate_js_sdk(output_dir)
        else:
            return {"status": "error", "error": f"Unsupported language: {self.language}"}

    def _generate_python_sdk(self, output_dir: Path) -> Dict[str, Any]:
        """Generate Python SDK for hardware control."""
        device_name = self.hardware_spec.get("device_name", "Device")
        class_name = device_name.replace(" ", "").replace("-", "")

        # Generate main SDK module
        sdk_code = [
            '"""',
            f"Python SDK for {device_name}",
            "Auto-generated by Accelerapp",
            '"""',
            "",
            "import serial",
            "from typing import Optional, Dict, Any",
            "",
            "",
            f"class {class_name}:",
            '    """',
            f"    Interface class for {device_name}",
            '    """',
            "",
            "    def __init__(self, port: str, baudrate: int = 9600):",
            '        """',
            "        Initialize connection to device.",
            "",
            "        Args:",
            "            port: Serial port (e.g., '/dev/ttyUSB0' or 'COM3')",
            "            baudrate: Communication speed",
            '        """',
            "        self.port = port",
            "        self.baudrate = baudrate",
            "        self.serial = None",
            "",
            "    def connect(self) -> bool:",
            '        """Establish connection to the device."""',
            "        try:",
            "            self.serial = serial.Serial(self.port, self.baudrate, timeout=1)",
            "            return True",
            "        except Exception as e:",
            "            print(f'Connection failed: {e}')",
            "            return False",
            "",
            "    def disconnect(self) -> None:",
            '        """Close connection to the device."""',
            "        if self.serial and self.serial.is_open:",
            "            self.serial.close()",
            "",
            "    def send_command(self, command: str) -> Optional[str]:",
            '        """',
            "        Send a command to the device.",
            "",
            "        Args:",
            "            command: Command string to send",
            "",
            "        Returns:",
            "            Response from device or None if error",
            '        """',
            "        if not self.serial or not self.serial.is_open:",
            "            return None",
            "",
            "        try:",
            "            self.serial.write(command.encode() + b'\\n')",
            "            response = self.serial.readline().decode().strip()",
            "            return response",
            "        except Exception as e:",
            "            print(f'Command failed: {e}')",
            "            return None",
            "",
        ]

        # Add methods for each peripheral
        peripherals = self.hardware_spec.get("peripherals", [])
        for peripheral in peripherals:
            p_type = peripheral["type"]
            method_name = f"control_{p_type}"

            sdk_code.extend(
                [
                    f"    def {method_name}(self, action: str, value: Any = None) -> Optional[str]:",
                    '        """',
                    f"        Control {p_type} peripheral.",
                    "",
                    "        Args:",
                    "            action: Action to perform",
                    "            value: Optional value parameter",
                    "",
                    "        Returns:",
                    "            Response from device",
                    '        """',
                    f"        command = f'{p_type}:{{action}}'",
                    "        if value is not None:",
                    "            command += f':{{value}}'",
                    "        return self.send_command(command)",
                    "",
                ]
            )

        # Add context manager support
        sdk_code.extend(
            [
                "    def __enter__(self):",
                "        self.connect()",
                "        return self",
                "",
                "    def __exit__(self, exc_type, exc_val, exc_tb):",
                "        self.disconnect()",
                "",
            ]
        )

        sdk_file = output_dir / f"{device_name.lower().replace(' ', '_')}_sdk.py"
        sdk_file.write_text("\n".join(sdk_code))

        # Generate example usage
        example_code = [
            '"""',
            f"Example usage of {device_name} SDK",
            '"""',
            "",
            f"from {device_name.lower().replace(' ', '_')}_sdk import {class_name}",
            "",
            "",
            "def main():",
            "    # Connect to device",
            f"    with {class_name}('/dev/ttyUSB0', 9600) as device:",
            "        print('Connected to device')",
            "",
        ]

        for peripheral in peripherals:
            p_type = peripheral["type"]
            example_code.extend(
                [
                    f"        # Control {p_type}",
                    f"        response = device.control_{p_type}('read')",
                    "        print(f'Response: {response}')",
                    "",
                ]
            )

        example_code.extend(["", "if __name__ == '__main__':", "    main()", ""])

        example_file = output_dir / "example.py"
        example_file.write_text("\n".join(example_code))

        # Generate requirements
        requirements = ["# Requirements for generated SDK", "pyserial>=3.5", ""]
        req_file = output_dir / "requirements.txt"
        req_file.write_text("\n".join(requirements))

        return {
            "status": "success",
            "language": "python",
            "files_generated": [str(sdk_file), str(example_file), str(req_file)],
            "output_dir": str(output_dir),
        }

    def _generate_cpp_sdk(self, output_dir: Path) -> Dict[str, Any]:
        """Generate C++ SDK for hardware control."""
        device_name = self.hardware_spec.get("device_name", "Device")
        class_name = device_name.replace(" ", "").replace("-", "")

        # Generate header
        header_code = [
            f"#ifndef {class_name.upper()}_H",
            f"#define {class_name.upper()}_H",
            "",
            "#include <string>",
            "#include <memory>",
            "",
            f"class {class_name} {{",
            "public:",
            "    explicit " + class_name + "(const std::string& port, int baudrate = 9600);",
            "    ~" + class_name + "();",
            "",
            "    bool connect();",
            "    void disconnect();",
            "    std::string sendCommand(const std::string& command);",
            "",
            "private:",
            "    std::string port_;",
            "    int baudrate_;",
            "    int serial_fd_;",
            "};",
            "",
            f"#endif // {class_name.upper()}_H",
            "",
        ]

        header_file = output_dir / f"{class_name}.h"
        header_file.write_text("\n".join(header_code))

        # Generate implementation
        impl_code = [
            f'#include "{class_name}.h"',
            "#include <iostream>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <termios.h>",
            "",
            f"{class_name}::{class_name}(const std::string& port, int baudrate)",
            "    : port_(port), baudrate_(baudrate), serial_fd_(-1) {}",
            "",
            f"{class_name}::~{class_name}() {{",
            "    disconnect();",
            "}",
            "",
            f"bool {class_name}::connect() {{",
            "    // Implementation of serial connection",
            "    return false;  // Placeholder",
            "}",
            "",
            f"void {class_name}::disconnect() {{",
            "    if (serial_fd_ >= 0) {",
            "        close(serial_fd_);",
            "        serial_fd_ = -1;",
            "    }",
            "}",
            "",
            f"std::string {class_name}::sendCommand(const std::string& command) {{",
            "    // Implementation of command sending",
            '    return "";  // Placeholder',
            "}",
            "",
        ]

        impl_file = output_dir / f"{class_name}.cpp"
        impl_file.write_text("\n".join(impl_code))

        return {
            "status": "success",
            "language": "cpp",
            "files_generated": [str(header_file), str(impl_file)],
            "output_dir": str(output_dir),
        }

    def _generate_js_sdk(self, output_dir: Path) -> Dict[str, Any]:
        """Generate JavaScript SDK for hardware control."""
        device_name = self.hardware_spec.get("device_name", "Device")
        class_name = device_name.replace(" ", "").replace("-", "")

        js_code = [
            "/**",
            f" * {device_name} SDK",
            " * Auto-generated by Accelerapp",
            " */",
            "",
            "const SerialPort = require('serialport');",
            "",
            f"class {class_name} {{",
            "  constructor(port, baudrate = 9600) {",
            "    this.port = port;",
            "    this.baudrate = baudrate;",
            "    this.serial = null;",
            "  }",
            "",
            "  connect() {",
            "    return new Promise((resolve, reject) => {",
            "      this.serial = new SerialPort(this.port, {",
            "        baudRate: this.baudrate",
            "      });",
            "",
            "      this.serial.on('open', () => resolve(true));",
            "      this.serial.on('error', (err) => reject(err));",
            "    });",
            "  }",
            "",
            "  disconnect() {",
            "    if (this.serial && this.serial.isOpen) {",
            "      this.serial.close();",
            "    }",
            "  }",
            "",
            "  sendCommand(command) {",
            "    return new Promise((resolve, reject) => {",
            "      if (!this.serial || !this.serial.isOpen) {",
            "        reject(new Error('Not connected'));",
            "        return;",
            "      }",
            "",
            "      this.serial.write(command + '\\n', (err) => {",
            "        if (err) reject(err);",
            "      });",
            "",
            "      this.serial.once('data', (data) => {",
            "        resolve(data.toString().trim());",
            "      });",
            "    });",
            "  }",
            "}",
            "",
            f"module.exports = {class_name};",
            "",
        ]

        sdk_file = output_dir / f"{class_name}.js"
        sdk_file.write_text("\n".join(js_code))

        # Generate package.json
        package_json = {
            "name": f"{device_name.lower().replace(' ', '-')}-sdk",
            "version": "0.1.0",
            "description": f"SDK for {device_name}",
            "main": f"{class_name}.js",
            "dependencies": {"serialport": "^10.0.0"},
        }

        import json

        pkg_file = output_dir / "package.json"
        pkg_file.write_text(json.dumps(package_json, indent=2))

        return {
            "status": "success",
            "language": "javascript",
            "files_generated": [str(sdk_file), str(pkg_file)],
            "output_dir": str(output_dir),
        }
