"""
Vulnerability scanning and security assessment system.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum


class Severity(Enum):
    """Vulnerability severity levels."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Represents a security vulnerability."""

    id: str
    title: str
    description: str
    severity: Severity
    component: str
    affected_versions: List[str] = field(default_factory=list)
    fixed_version: Optional[str] = None
    cve_id: Optional[str] = None
    remediation: Optional[str] = None
    discovered_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())


@dataclass
class ScanResult:
    """Represents a security scan result."""

    scan_id: str
    timestamp: str
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    total_scanned: int = 0
    scan_duration_seconds: float = 0.0


class VulnerabilityScanner:
    """
    Vulnerability scanning and security assessment system.
    """

    def __init__(self):
        """Initialize vulnerability scanner."""
        self.scan_results: List[ScanResult] = []
        self.known_vulnerabilities: Dict[str, Vulnerability] = {}

    def scan_dependencies(self, dependencies: List[str]) -> ScanResult:
        """
        Scan dependencies for known vulnerabilities.

        Args:
            dependencies: List of dependency specifications

        Returns:
            ScanResult
        """
        scan_id = f"scan-{datetime.utcnow().timestamp()}"
        timestamp = datetime.utcnow().isoformat()
        vulnerabilities = []

        # Simulate vulnerability scanning
        for dep in dependencies:
            # Check against known vulnerabilities
            if dep in self.known_vulnerabilities:
                vulnerabilities.append(self.known_vulnerabilities[dep])

        result = ScanResult(
            scan_id=scan_id,
            timestamp=timestamp,
            vulnerabilities=vulnerabilities,
            total_scanned=len(dependencies),
            scan_duration_seconds=0.0,
        )

        self.scan_results.append(result)
        return result

    def scan_code(self, code_paths: List[str]) -> ScanResult:
        """
        Scan code for security issues.

        Args:
            code_paths: List of code file paths

        Returns:
            ScanResult
        """
        scan_id = f"code-scan-{datetime.utcnow().timestamp()}"
        timestamp = datetime.utcnow().isoformat()
        vulnerabilities = []

        # Simplified scanning logic
        # In real implementation, would check for:
        # - hardcoded_secrets, sql_injection, command_injection, weak_crypto
        for path in code_paths:
            # Would scan file contents here
            pass

        result = ScanResult(
            scan_id=scan_id,
            timestamp=timestamp,
            vulnerabilities=vulnerabilities,
            total_scanned=len(code_paths),
            scan_duration_seconds=0.0,
        )

        self.scan_results.append(result)
        return result

    def add_vulnerability(
        self,
        vuln_id: str,
        title: str,
        description: str,
        severity: Severity,
        component: str,
        affected_versions: Optional[List[str]] = None,
        fixed_version: Optional[str] = None,
        cve_id: Optional[str] = None,
        remediation: Optional[str] = None,
    ) -> Vulnerability:
        """
        Add a known vulnerability to the database.

        Args:
            vuln_id: Vulnerability ID
            title: Vulnerability title
            description: Vulnerability description
            severity: Severity level
            component: Affected component
            affected_versions: Affected versions
            fixed_version: Fixed version
            cve_id: CVE identifier
            remediation: Remediation steps

        Returns:
            Vulnerability
        """
        vuln = Vulnerability(
            id=vuln_id,
            title=title,
            description=description,
            severity=severity,
            component=component,
            affected_versions=affected_versions or [],
            fixed_version=fixed_version,
            cve_id=cve_id,
            remediation=remediation,
        )

        self.known_vulnerabilities[vuln_id] = vuln
        return vuln

    def get_scan_results(self, scan_id: Optional[str] = None) -> List[ScanResult]:
        """
        Get scan results.

        Args:
            scan_id: Optional scan ID filter

        Returns:
            List of ScanResult
        """
        if scan_id:
            return [r for r in self.scan_results if r.scan_id == scan_id]
        return self.scan_results

    def get_vulnerabilities_by_severity(self, severity: Severity) -> List[Vulnerability]:
        """
        Get vulnerabilities by severity.

        Args:
            severity: Severity level

        Returns:
            List of Vulnerability
        """
        all_vulns = []
        for result in self.scan_results:
            all_vulns.extend(result.vulnerabilities)

        return [v for v in all_vulns if v.severity == severity]

    def get_statistics(self) -> Dict[str, Any]:
        """
        Get security statistics.

        Returns:
            Statistics dictionary
        """
        total_scans = len(self.scan_results)
        total_vulnerabilities = sum(len(r.vulnerabilities) for r in self.scan_results)

        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0,
        }

        for result in self.scan_results:
            for vuln in result.vulnerabilities:
                severity_counts[vuln.severity.value] += 1

        return {
            "total_scans": total_scans,
            "total_vulnerabilities": total_vulnerabilities,
            "vulnerabilities_by_severity": severity_counts,
            "known_vulnerabilities": len(self.known_vulnerabilities),
        }

    def generate_security_report(self) -> Dict[str, Any]:
        """
        Generate comprehensive security report.

        Returns:
            Security report dictionary
        """
        stats = self.get_statistics()
        critical_vulns = self.get_vulnerabilities_by_severity(Severity.CRITICAL)
        high_vulns = self.get_vulnerabilities_by_severity(Severity.HIGH)

        return {
            "summary": stats,
            "critical_vulnerabilities": [
                {
                    "id": v.id,
                    "title": v.title,
                    "component": v.component,
                    "cve_id": v.cve_id,
                }
                for v in critical_vulns
            ],
            "high_vulnerabilities": [
                {
                    "id": v.id,
                    "title": v.title,
                    "component": v.component,
                    "cve_id": v.cve_id,
                }
                for v in high_vulns
            ],
            "recommendations": self._generate_recommendations(critical_vulns, high_vulns),
        }

    def _generate_recommendations(
        self, critical_vulns: List[Vulnerability], high_vulns: List[Vulnerability]
    ) -> List[str]:
        """Generate security recommendations."""
        recommendations = []

        if critical_vulns:
            recommendations.append(
                f"URGENT: Address {len(critical_vulns)} critical vulnerabilities immediately"
            )

        if high_vulns:
            recommendations.append(
                f"Address {len(high_vulns)} high severity vulnerabilities as soon as possible"
            )

        if not critical_vulns and not high_vulns:
            recommendations.append("No critical or high severity vulnerabilities found")
            recommendations.append("Continue regular security scanning")

        return recommendations
