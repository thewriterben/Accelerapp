"""
FreeRTOS configuration generator.
Generates FreeRTOSConfig.h with optimized settings.
"""

from typing import Dict, Any


class FreeRTOSConfigGenerator:
    """
    Generator for FreeRTOS configuration file (FreeRTOSConfig.h).
    Provides platform-optimized settings.
    """

    def __init__(self, platform: str = "stm32"):
        """
        Initialize config generator.
        
        Args:
            platform: Target platform (stm32, nrf52, esp32, etc.)
        """
        self.platform = platform
        
    def generate_config(self, config: Dict[str, Any]) -> str:
        """
        Generate complete FreeRTOSConfig.h file.
        
        Args:
            config: Configuration options
            
        Returns:
            Generated configuration file content
        """
        cpu_clock = config.get("cpu_clock_hz", 84000000)
        tick_rate_hz = config.get("tick_rate_hz", 1000)
        max_priorities = config.get("max_priorities", 5)
        minimal_stack_size = config.get("minimal_stack_size", 128)
        total_heap_size = config.get("total_heap_size", 15360)
        
        lines = [
            "/* FreeRTOS Configuration */",
            f"/* Generated by Accelerapp v2.0 for {self.platform} */",
            "",
            "#ifndef FREERTOS_CONFIG_H",
            "#define FREERTOS_CONFIG_H",
            "",
            "/*-----------------------------------------------------------",
            " * Application specific definitions.",
            " *",
            " * These definitions should be adjusted for your particular hardware and",
            " * application requirements.",
            " *----------------------------------------------------------*/",
            "",
            "/* Kernel configuration */",
            f"#define configUSE_PREEMPTION              1",
            f"#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0",
            f"#define configUSE_TICKLESS_IDLE           {1 if config.get('tickless_idle') else 0}",
            f"#define configCPU_CLOCK_HZ                ({cpu_clock}UL)",
            f"#define configTICK_RATE_HZ                ({tick_rate_hz})",
            f"#define configMAX_PRIORITIES              ({max_priorities})",
            f"#define configMINIMAL_STACK_SIZE          ((uint16_t){minimal_stack_size})",
            f"#define configTOTAL_HEAP_SIZE             ((size_t){total_heap_size})",
            f"#define configMAX_TASK_NAME_LEN           (16)",
            "",
        ]
        
        # Feature flags
        lines.extend([
            "/* Feature configuration */",
            f"#define configUSE_16_BIT_TICKS            0",
            f"#define configIDLE_SHOULD_YIELD           1",
            f"#define configUSE_TASK_NOTIFICATIONS      1",
            f"#define configUSE_MUTEXES                 {1 if config.get('use_mutexes', True) else 0}",
            f"#define configUSE_RECURSIVE_MUTEXES       {1 if config.get('use_recursive_mutexes') else 0}",
            f"#define configUSE_COUNTING_SEMAPHORES     {1 if config.get('use_counting_semaphores', True) else 0}",
            f"#define configUSE_QUEUE_SETS              {1 if config.get('use_queue_sets') else 0}",
            f"#define configUSE_TIME_SLICING            1",
            f"#define configUSE_NEWLIB_REENTRANT        0",
            "",
        ])
        
        # Memory allocation
        lines.extend([
            "/* Memory allocation related definitions */",
            f"#define configSUPPORT_STATIC_ALLOCATION   {1 if config.get('static_allocation') else 0}",
            f"#define configSUPPORT_DYNAMIC_ALLOCATION  1",
            f"#define configAPPLICATION_ALLOCATED_HEAP  0",
            "",
        ])
        
        # Hook functions
        lines.extend([
            "/* Hook function related definitions */",
            f"#define configUSE_IDLE_HOOK               {1 if config.get('use_idle_hook') else 0}",
            f"#define configUSE_TICK_HOOK               {1 if config.get('use_tick_hook') else 0}",
            f"#define configCHECK_FOR_STACK_OVERFLOW    {config.get('stack_overflow_check', 2)}",
            f"#define configUSE_MALLOC_FAILED_HOOK      {1 if config.get('use_malloc_failed_hook', True) else 0}",
            f"#define configUSE_DAEMON_TASK_STARTUP_HOOK 0",
            "",
        ])
        
        # Co-routine definitions
        lines.extend([
            "/* Co-routine definitions */",
            f"#define configUSE_CO_ROUTINES             0",
            f"#define configMAX_CO_ROUTINE_PRIORITIES   (2)",
            "",
        ])
        
        # Software timer definitions
        lines.extend([
            "/* Software timer definitions */",
            f"#define configUSE_TIMERS                  {1 if config.get('use_timers', True) else 0}",
            f"#define configTIMER_TASK_PRIORITY         ({config.get('timer_task_priority', 2)})",
            f"#define configTIMER_QUEUE_LENGTH          ({config.get('timer_queue_length', 10)})",
            f"#define configTIMER_TASK_STACK_DEPTH      ({config.get('timer_task_stack_depth', 128)})",
            "",
        ])
        
        # Platform-specific definitions
        if self.platform in ["stm32", "stm32f4", "stm32h7"]:
            lines.extend(self._get_stm32_specific_config())
        elif self.platform in ["nrf52", "nrf53"]:
            lines.extend(self._get_nrf_specific_config())
        elif self.platform == "esp32":
            lines.extend(self._get_esp32_specific_config())
        
        # Interrupt priorities
        lines.extend([
            "/* Interrupt nesting behaviour configuration */",
            "#define configKERNEL_INTERRUPT_PRIORITY         [dependent of processor]",
            "#define configMAX_SYSCALL_INTERRUPT_PRIORITY    [dependent of processor and application]",
            "#define configMAX_API_CALL_INTERRUPT_PRIORITY   [dependent of processor and application]",
            "",
        ])
        
        # Optional functions
        lines.extend([
            "/* Optional functions */",
            "#define INCLUDE_vTaskPrioritySet          1",
            "#define INCLUDE_uxTaskPriorityGet         1",
            "#define INCLUDE_vTaskDelete               1",
            "#define INCLUDE_vTaskSuspend              1",
            "#define INCLUDE_xResumeFromISR            1",
            "#define INCLUDE_vTaskDelayUntil           1",
            "#define INCLUDE_vTaskDelay                1",
            "#define INCLUDE_xTaskGetSchedulerState    1",
            "#define INCLUDE_xTaskGetCurrentTaskHandle 1",
            "#define INCLUDE_uxTaskGetStackHighWaterMark 1",
            "#define INCLUDE_xTaskGetIdleTaskHandle    1",
            "#define INCLUDE_eTaskGetState             1",
            "#define INCLUDE_xEventGroupSetBitFromISR  1",
            "#define INCLUDE_xTimerPendFunctionCall    1",
            "#define INCLUDE_xTaskAbortDelay           1",
            "#define INCLUDE_xTaskGetHandle            1",
            "#define INCLUDE_xTaskResumeFromISR        1",
            "",
        ])
        
        # Assert definition
        lines.extend([
            "/* Assertions */",
            "#define configASSERT(x) if((x) == 0) { taskDISABLE_INTERRUPTS(); for(;;); }",
            "",
            "#endif /* FREERTOS_CONFIG_H */",
            "",
        ])
        
        return "\n".join(lines)
    
    def _get_stm32_specific_config(self) -> list:
        """Get STM32-specific FreeRTOS configuration."""
        return [
            "/* STM32 Cortex-M specific definitions */",
            "#ifdef __NVIC_PRIO_BITS",
            "    #define configPRIO_BITS __NVIC_PRIO_BITS",
            "#else",
            "    #define configPRIO_BITS 4",
            "#endif",
            "",
            "/* The lowest interrupt priority that can be used in a call to a 'set priority' function */",
            "#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY 15",
            "",
            "/* The highest interrupt priority that can be used by any interrupt service",
            "   routine that makes calls to interrupt safe FreeRTOS API functions */",
            "#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5",
            "",
            "#define configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))",
            "#define configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))",
            "",
            "/* Cortex-M specific port macros */",
            "#define vPortSVCHandler SVC_Handler",
            "#define xPortPendSVHandler PendSV_Handler",
            "#define xPortSysTickHandler SysTick_Handler",
            "",
        ]
    
    def _get_nrf_specific_config(self) -> list:
        """Get nRF-specific FreeRTOS configuration."""
        return [
            "/* Nordic nRF Cortex-M specific definitions */",
            "#define configPRIO_BITS 3",
            "#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY 7",
            "#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 3",
            "",
            "#define configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))",
            "#define configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))",
            "",
            "/* Nordic SoftDevice integration */",
            "#define configUSE_TICKLESS_IDLE 1",
            "",
        ]
    
    def _get_esp32_specific_config(self) -> list:
        """Get ESP32-specific FreeRTOS configuration."""
        return [
            "/* ESP32 specific definitions */",
            "#define configNUM_CORES 2",
            "#define configUSE_CORE_AFFINITY 1",
            "",
        ]
